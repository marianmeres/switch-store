"use strict";const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=t=>e(t.subscribe),s=(r,s=null)=>{const n=t=>e(s?.persist)&&s.persist(t);let i=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r)=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const s=r(e,(e=>{t(e),s()}));return s},unsubscribeAll:t=>e.delete(t)}})(),u=r;n(u);const c=()=>u,o=e=>{u!==e&&(u=e,n(u),i.publish("change",u))};return{set:o,get:c,update:e=>{t(e,"[update]"),o(e(c()))},subscribe:e=>(t(e,"[subscribe]"),e(u),i.subscribe("change",e))}};exports.createSwitchStore=(n,i=null,u=null)=>{const c=e=>null==e?null:!!e,o=s({value:c(n),data:i},u),a=((n,i,u=null)=>{const c=t=>e(u?.persist)&&u.persist(t),o=s(u?.initialValue),a=[];if(n.forEach((e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>a.push(e)))()})),!e(i))throw new TypeError("Expecting second argument to be the derivative function");if(!i.length||i.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let l=0,b=[];return{get:o.get,subscribe:e=>{t(e,"[derived.subscribe]"),l++||n.forEach(((e,t)=>{b.push(e.subscribe((e=>{a[t]=e,1===i.length?(o.set(i(a)),c(o.get())):i(a,(e=>{o.set(e),c(o.get())}))})))}));const r=o.subscribe(e);return()=>{--l||(b.forEach((e=>e())),b=[]),r()}}}})([o],(([e])=>{const t=!0===e.value,r=null===e.value,s=!t;return{data:e.data,isOn:t,isOff:s,isUndefined:r,isOpen:t,isClosed:s}})),l=(e,t)=>{let r=o.get();void 0!==t&&(r={...r,data:t}),o.set({...r,value:c(e)})},b=(...e)=>e[e.length>1?1:0],g=(...e)=>l(!0,b(...e)),p=(...e)=>l(!1,b(...e)),h=(...e)=>l(void 0,b(...e));return{subscribe:a.subscribe,get:a.get,on:g,off:p,unset:h,toggle:()=>o.update((e=>({...e,value:c(!e.value)}))),toggleUnset:()=>o.get().value?h():g(),open:g,close:p}};
