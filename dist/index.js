const e=e=>"function"==typeof e,t=(t,r="")=>{if(!e(t))throw new TypeError(`${r} Expecting function arg`.trim())},r=t=>e(t.subscribe),n=(r,n=null)=>{const s=t=>e(n?.persist)&&n.persist(t);let u=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),r=(e,r)=>{if("function"!=typeof r)throw new TypeError("Expecting callback function as second argument");return t(e).add(r),()=>t(e).delete(r)};return{publish:(e,r)=>{t(e).forEach((e=>e(r)))},subscribe:r,subscribeOnce:(e,t)=>{const n=r(e,(e=>{t(e),n()}));return n},unsubscribeAll:t=>e.delete(t)}})(),i=r;s(i);const o=()=>i,c=e=>{i!==e&&(i=e,s(i),u.publish("change",i))};return{set:c,get:o,update:e=>{t(e,"[update]"),c(e(o()))},subscribe:e=>(t(e,"[subscribe]"),e(i),u.subscribe("change",e))}},s=(s,u=null,i=null)=>{const o=e=>null==e?null:!!e,c=n({value:o(s),data:u},i),l=((s,u,i=null)=>{const o=t=>e(i?.persist)&&i.persist(t),c=n(i?.initialValue),l=[];if(s.forEach((e=>{if(!r(e))throw new TypeError("Expecting array of StoreLike objects");e.subscribe((e=>l.push(e)))()})),!e(u))throw new TypeError("Expecting second argument to be the derivative function");if(!u.length||u.length>2)throw new TypeError("Expecting the derivative function to have exactly 1 or 2 arguments");let a=0,b=[];return{get:c.get,subscribe:e=>{t(e,"[derived.subscribe]"),a++||s.forEach(((e,t)=>{b.push(e.subscribe((e=>{l[t]=e,1===u.length?(c.set(u(l)),o(c.get())):u(l,(e=>{c.set(e),o(c.get())}))})))}));const r=c.subscribe(e);return()=>{--a||(b.forEach((e=>e())),b=[]),r()}}}})([c],(([e])=>{const t=!0===e.value,r=null===e.value,n=!t;return{data:e.data,isOn:t,isOff:n,isUndefined:r,isOpen:t,isClosed:n}})),a=(e,t)=>{let r=c.get();void 0!==t&&(r={...r,data:t}),c.set({...r,value:o(e)})},b=(...e)=>e[e.length>1?1:0],g=(...e)=>a(!0,b(...e)),p=(...e)=>a(!1,b(...e)),f=(...e)=>a(void 0,b(...e));return{subscribe:l.subscribe,get:l.get,on:g,off:p,unset:f,toggle:()=>c.update((e=>({...e,value:o(!e.value)}))),toggleUnset:()=>c.get().value?f():g(),open:g,close:p}};export{s as createSwitchStore};
